{"ast":null,"code":"import { EventdataTypes } from \"../types\";\nconst initialState = {\n  activeWindows: [],\n  clusterToColor: {},\n  visibleClusters: [],\n  events: [],\n  clusters: []\n};\n\nconst EventdataReducer = (state = initialState, action) => {\n  switch (action.type) {\n    case EventdataTypes.SET_ACTIVE_WINDOWS:\n      let events0 = state.activeWindows.filter(event => {\n        let temp;\n\n        for (temp = 0; temp < event.cluster.length; temp++) {\n          if (state.visibleClusters.includes(event.cluster[temp])) return true;\n        }\n\n        return false;\n      });\n      return { ...state,\n        activeWindows: action.payload,\n        events: events0\n      };\n\n    case EventdataTypes.SET_CLUSTER_LABELS:\n      return { ...state,\n        clusterToColor: { ...action.payload.clusterToColor,\n          0: \"#FF7F50\",\n          1: \"#ffcc66\",\n          2: \"#ff66cc\",\n          3: \"#00ffcc\",\n          4: \"#87CEFA\",\n          5: \"#7FFFD4\"\n        },\n        clusters: action.payload.clusters\n      };\n\n    case EventdataTypes.ADD_CLUSTER_VISIBLE:\n      let visibleClusters = [...state.visibleClusters];\n      if (action.payload >= 0 && !state.visibleClusters.includes(action.payload)) visibleClusters.splice(0, 0, action.payload);\n      let events = state.activeWindows.filter(event => {\n        let temp;\n\n        for (temp = 0; temp < event.cluster.length; temp++) {\n          if (visibleClusters.includes(event.cluster[temp])) return true;\n        }\n\n        return false;\n      });\n      return { ...state,\n        visibleClusters: visibleClusters,\n        events: events\n      };\n\n    case EventdataTypes.REMOVE_CLUSTER_VISIBLE:\n      let visibleClusters2 = [...state.visibleClusters];\n      if (action.payload >= 0 && state.visibleClusters.includes(action.payload)) visibleClusters2.splice(visibleClusters2.indexOf(action.payload), 1);\n      let events2 = state.activeWindows.filter(event => {\n        let temp;\n\n        for (temp = 0; temp < event.cluster.length; temp++) {\n          if (visibleClusters2.includes(event.cluster[temp])) return true;\n        }\n\n        return false;\n      });\n      return { ...state,\n        visibleClusters: visibleClusters2,\n        events: events2\n      };\n\n    case EventdataTypes.ADD_TO_EVENT_CLUSTER:\n      return { ...state,\n        activeWindows: state.activeWindows.map(event => {\n          if (event.id === action.payload.eventId) {\n            if (event.cluster.indexOf(action.payload.cluster) == -1) event.cluster.splice(0, 0, action.payload.cluster);\n          }\n\n          return event;\n        }),\n        events: state.events.map(event => {\n          if (event.id === action.payload.eventId) {\n            if (event.cluster.indexOf(action.payload.cluster) == -1) event.cluster.splice(0, 0, action.payload.cluster);\n          }\n\n          return event;\n        })\n      };\n\n    case EventdataTypes.REMOVE_FROM_EVENT_CLUSTER:\n      return { ...state,\n        activeWindows: state.activeWindows.map(event => {\n          if (event.id === action.payload.eventId) {\n            if (event.cluster.includes(action.payload.cluster)) event.cluster.splice(event.cluster.indexOf(action.payload.cluster), 1);\n          }\n\n          return event;\n        }),\n        events: state.events.map(event => {\n          if (event.id === action.payload.eventId) {\n            if (event.cluster.includes(action.payload.cluster)) event.cluster.splice(event.cluster.indexOf(action.payload.cluster), 1);\n          }\n\n          return event;\n        })\n      };\n\n    case EventdataTypes.CONVERT_DURATION_CLUSTER:\n      return { ...state,\n        activeWindows: state.activeWindows.map(event => {\n          if (event.start > action.payload.start && event.start < action.payload.end || event.end > action.payload.start && event.end < action.payload.end) {\n            event.cluster = [...action.payload.cluster];\n          }\n\n          return event;\n        }),\n        events: state.events.map(event => {\n          if (event.start > action.payload.start && event.start < action.payload.end || event.end > action.payload.start && event.end < action.payload.end) {\n            event.cluster = [...action.payload.cluster];\n          }\n\n          return event;\n        })\n      };\n\n    case EventdataTypes.SET_EVENTS:\n      return { ...state,\n        events: action.payload\n      };\n\n    case EventdataTypes.UPDATE_CLUSTER_LABELS:\n      return { ...state,\n        clusters: action.payload.newClusters\n      };\n\n    default:\n      return state;\n  }\n};\n\n_c = EventdataReducer;\nexport default EventdataReducer;\n\nvar _c;\n\n$RefreshReg$(_c, \"EventdataReducer\");","map":{"version":3,"sources":["/Users/minakhan/git/PAL_2021/PAL_Stroop/Visualization_app/src/redux/reducers/eventdata.reducer.js"],"names":["EventdataTypes","initialState","activeWindows","clusterToColor","visibleClusters","events","clusters","EventdataReducer","state","action","type","SET_ACTIVE_WINDOWS","events0","filter","event","temp","cluster","length","includes","payload","SET_CLUSTER_LABELS","ADD_CLUSTER_VISIBLE","splice","REMOVE_CLUSTER_VISIBLE","visibleClusters2","indexOf","events2","ADD_TO_EVENT_CLUSTER","map","id","eventId","REMOVE_FROM_EVENT_CLUSTER","CONVERT_DURATION_CLUSTER","start","end","SET_EVENTS","UPDATE_CLUSTER_LABELS","newClusters"],"mappings":"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","sourcesContent":["import { EventdataTypes } from \"../types\";\nconst initialState = {\n  activeWindows: [],\n  clusterToColor: {},\n  visibleClusters: [],\n  events: [],\n  clusters: []\n};\n\nconst EventdataReducer = (state = initialState, action) => {\n  switch (action.type) {\n    case EventdataTypes.SET_ACTIVE_WINDOWS:\n      let events0 = state.activeWindows.filter(event => {\n        let temp;\n        for (temp = 0; temp < event.cluster.length; temp++) {\n          if (state.visibleClusters.includes(event.cluster[temp])) return true;\n        }\n        return false;\n      });\n      return { ...state, activeWindows: action.payload, events: events0 };\n    case EventdataTypes.SET_CLUSTER_LABELS:\n      return {\n        ...state,\n        clusterToColor: {\n          ...action.payload.clusterToColor,\n          0: \"#FF7F50\",\n          1: \"#ffcc66\",\n          2: \"#ff66cc\",\n          3: \"#00ffcc\",\n          4: \"#87CEFA\",\n          5: \"#7FFFD4\"\n        },\n        clusters: action.payload.clusters\n      };\n    case EventdataTypes.ADD_CLUSTER_VISIBLE:\n      let visibleClusters = [...state.visibleClusters];\n      if (\n        action.payload >= 0 &&\n        !state.visibleClusters.includes(action.payload)\n      )\n        visibleClusters.splice(0, 0, action.payload);\n      let events = state.activeWindows.filter(event => {\n        let temp;\n        for (temp = 0; temp < event.cluster.length; temp++) {\n          if (visibleClusters.includes(event.cluster[temp])) return true;\n        }\n        return false;\n      });\n      return { ...state, visibleClusters: visibleClusters, events: events };\n    case EventdataTypes.REMOVE_CLUSTER_VISIBLE:\n      let visibleClusters2 = [...state.visibleClusters];\n      if (action.payload >= 0 && state.visibleClusters.includes(action.payload))\n        visibleClusters2.splice(visibleClusters2.indexOf(action.payload), 1);\n\n      let events2 = state.activeWindows.filter(event => {\n        let temp;\n        for (temp = 0; temp < event.cluster.length; temp++) {\n          if (visibleClusters2.includes(event.cluster[temp])) return true;\n        }\n        return false;\n      });\n      return { ...state, visibleClusters: visibleClusters2, events: events2 };\n\n    case EventdataTypes.ADD_TO_EVENT_CLUSTER:\n      return {\n        ...state,\n        activeWindows: state.activeWindows.map(event => {\n          if (event.id === action.payload.eventId) {\n            if (event.cluster.indexOf(action.payload.cluster) == -1)\n              event.cluster.splice(0, 0, action.payload.cluster);\n          }\n          return event;\n        }),\n        events: state.events.map(event => {\n          if (event.id === action.payload.eventId) {\n            if (event.cluster.indexOf(action.payload.cluster) == -1)\n              event.cluster.splice(0, 0, action.payload.cluster);\n          }\n          return event;\n        })\n      };\n\n    case EventdataTypes.REMOVE_FROM_EVENT_CLUSTER:\n      return {\n        ...state,\n        activeWindows: state.activeWindows.map(event => {\n          if (event.id === action.payload.eventId) {\n            if (event.cluster.includes(action.payload.cluster))\n              event.cluster.splice(\n                event.cluster.indexOf(action.payload.cluster),\n                1\n              );\n          }\n          return event;\n        }),\n        events: state.events.map(event => {\n          if (event.id === action.payload.eventId) {\n            if (event.cluster.includes(action.payload.cluster))\n              event.cluster.splice(\n                event.cluster.indexOf(action.payload.cluster),\n                1\n              );\n          }\n          return event;\n        })\n      };\n\n    case EventdataTypes.CONVERT_DURATION_CLUSTER:\n      return {\n        ...state,\n        activeWindows: state.activeWindows.map(event => {\n          if (\n            (event.start > action.payload.start &&\n              event.start < action.payload.end) ||\n            (event.end > action.payload.start && event.end < action.payload.end)\n          ) {\n            event.cluster = [...action.payload.cluster];\n          }\n          return event;\n        }),\n        events: state.events.map(event => {\n          if (\n            (event.start > action.payload.start &&\n              event.start < action.payload.end) ||\n            (event.end > action.payload.start && event.end < action.payload.end)\n          ) {\n            event.cluster = [...action.payload.cluster];\n          }\n          return event;\n        })\n      };\n\n    case EventdataTypes.SET_EVENTS:\n      return { ...state, events: action.payload };\n\n    case EventdataTypes.UPDATE_CLUSTER_LABELS:\n      return { ...state, clusters: action.payload.newClusters };\n\n    default:\n      return state;\n  }\n};\n\nexport default EventdataReducer;\n"]},"metadata":{},"sourceType":"module"}